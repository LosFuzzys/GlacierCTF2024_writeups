#!/usr/bin/sage -python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host localhost --port 1337
from pwn import *
import re

from collections import namedtuple
from math import log2

import numpy as np

from sage.all import matrix, vector, QQ
from hashlib import sha1

# Set up pwntools for the correct architecture
context.update(arch='amd64')
# Just set TERM_PROGRAM in your ~/.profile!
# context.update(terminal='CHANGEME')
exe = context.binary = ELF(args.EXE or 'challenge')
host = args.HOST or 'localhost'
port = int(args.PORT or 1337)

# Find flag by exact match or format
# log.success(find_flag(io.recvall()))
real_flag = open("./flag.txt", "r").readline().strip()
fake_flag = open("./flag-fake.txt", "r").readline().strip()
def find_flag(output):
    if not isinstance(output, str):
        output = output.decode(errors="ignore")
    # Match real flag
    if real_flag in output:
        return real_flag
    # Match fake flag
    if fake_flag in output:
        return fake_flag
    # Match possible local flag
    with open("/flag.txt", "r") as local:
        locl_flag = local.readline().strip()
        if locl_flag in output:
            return locl_flag
    # Match regexp flag
    r = find_flag_fmt(output)
    if r is not None:
        return r
    # Definitely no flag found
    return None

# Find flag by format
# log.success(find_flag_fmt(io.recvall()))
ffmt = re.compile(r"gctf{.*}")
def find_flag_fmt(output):
    if not isinstance(output, str):
        output = output.decode(errors="ignore")
    m = ffmt.search(output)
    if m is None:
        return None
    return m.group(0)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

N = 0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed

# Shamelessly copied from https://wiki.x10sec.org/crypto/asymmetric/lattice/cvp/
def babai(A, w):
    A = A.LLL(delta=0.75)
    G, _ = A.gram_schmidt()
    t = w
    for i in reversed(range(A.nrows())):
        c = ((t * G[i]) / (G[i] * G[i])).round()
        t -= A[i] * c
    return w - t

io = start()

signatures = {}

io.recvuntil(b'public key: ')
public_key = bytes.fromhex(io.recvline().decode().strip())

Signature = namedtuple('Signature', ['h', 'r_g', 's'])

num_signatures = 5
for i in range(num_signatures):
    msg = f'{i}'.encode()
    io.recvuntil(b'msg> ')
    io.sendline(msg)

    io.recvuntil(b'signature: ')
    r_g, s = io.recvline().decode().strip().split()
    r_g, s = bytes.fromhex(r_g), bytes.fromhex(s)
    h = sha1(r_g + public_key + msg).digest()

    signatures[i] = Signature(int.from_bytes(h, 'little'), int.from_bytes(r_g, 'little'), int.from_bytes(s, 'little'))

# s = r + h * secret
# --> h * secret â‰ˆ s - r mod N

# target vector
# sec * 2**-100   s1      s2      s3      s4

# lattice
# 2**-100         h1      h2      h3      h4
# 0               N       0       0       0
# 0               0       N       0       0
# 0               0       0       N       0
# 0               0       0       0       N


lattice = matrix(QQ, num_signatures + 1, num_signatures + 1)
target_vector = vector(QQ, num_signatures + 1)

scaling_factor = 2**100
lattice[0, 0] = QQ((1, scaling_factor))
target_vector[0] = QQ((N / 2, scaling_factor))
for i in range(1, num_signatures + 1):
    lattice[i, i] = N

    lattice[0, i] = signatures[i - 1].h
    target_vector[i] = signatures[i - 1].s - 2**159

result = babai(lattice, target_vector)

private_key = int(result[0] * scaling_factor)
print('private key:', private_key.to_bytes(32, 'little').hex())

io.sendline()
io.recvuntil(b'sign this: ')
challenge = io.recvline().strip()

r_g = signatures[0].r_g.to_bytes(32, 'little')
challenge_hash = sha1(r_g + public_key + challenge).digest()
h_new = int.from_bytes(challenge_hash, 'little')
h_old = signatures[0].h

s_old = signatures[0].s
s_new = (s_old + (h_new - h_old) * private_key) % N
s_new = s_new.to_bytes(32, 'little')

io.recvuntil(b'signature> ')
io.sendline(f'{r_g.hex()} {s_new.hex()}'.encode())

f = find_flag(io.recvall())
if f is not None:
    log.success(f)
    exit(0)
else:
    exit(1)

# vim:filetype=python
