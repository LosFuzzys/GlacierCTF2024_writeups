#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host localhost --port 1337
from pwn import *
import re
import aes
from aeskeyschedule import reverse_key_schedule, key_schedule
import itertools

# Set up pwntools for the correct architecture
# Just set TERM_PROGRAM in your ~/.profile!
# context.update(terminal='CHANGEME')
exe = (args.EXE or 'challenge')
host = args.HOST or 'localhost'
port = int(args.PORT or 1337)

# Find flag by exact match or format
# log.success(find_flag(io.recvall()))
def find_flag(output):
    if not isinstance(output, str):
        output = output.decode(errors="ignore")
    # Match real flag
    if real_flag in output:
        return real_flag
    # Match fake flag
    if fake_flag in output:
        return fake_flag
    # Match possible local flag
    with open("/flag.txt", "r") as local:
        locl_flag = local.readline().strip()
        if locl_flag in output:
            return locl_flag
    # Match regexp flag
    r = find_flag_fmt(output)
    if r is not None:
        return r
    # Definitely no flag found
    return None


# Find flag by format
# log.success(find_flag_fmt(io.recvall()))
ffmt = re.compile(r"gctf{.*}")
def find_flag_fmt(output):
    if not isinstance(output, str):
        output = output.decode(errors="ignore")
    m = ffmt.search(output)
    if m is None:
        return None
    return m.group(0)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    return process([exe] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)


def expand_key(key: bytes, rounds: int) -> list[list[int]]:
    round_keys = [[key[i : i + 4] for i in range(0, len(key), 4)]]
    while len(round_keys) < rounds + 1:
        base_key = b"".join(round_keys[-1])
        round_keys += aes.expand_key(base_key, 10)[1:]
    round_keys = [b"".join(k) for k in round_keys]
    round_keys = [aes.bytes2matrix(k) for k in round_keys]
    return round_keys[:rounds + 1]


def encrypt_block(pt: bytes, key: bytes, rounds: int) -> bytes:
    if len(pt) != 16 or len(key) != 16:
        exit(1)
    subkeys = expand_key(key, rounds)
    block = aes.bytes2matrix(pt)
    aes.add_round_key(block, subkeys[0])
    for i in range(1, rounds+1):
        aes.sub_bytes(block)
        aes.shift_rows(block)
        aes.mix_columns(block)
        aes.add_round_key(block, subkeys[i])

    return aes.matrix2bytes(block)

PREMIUM_USER = b"premium"
#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
from Crypto.Util.Padding import pad

def send_encrypted(io, option, pt, code:bytes=None):
    io.sendlineafter(b"Enter option (1: Encrypt, 2: Premium Encrypt, 3: Guess Key):", option)
    if option == "2":
        print(code)
        io.sendlineafter(b"Enter ciphertext:", code)
    io.sendlineafter(b"Enter plaintext: ", pt)
    ct = bytes.fromhex(io.recvline().strip().decode()[11:])
    ct1, ct2 = ct[:16], ct[16:32]
    return ct1, ct2

print("Exploiting...")
io = start()

NORMAL_ROUND = 22
PREMIUM_ROUNDS = 24
key_size = 16

# The the admin code
code, _ = send_encrypted(io, "1", pad(PREMIUM_USER, 16)+b"a")
print(code)
assert len(code) == 16
code = code.hex()

pt1 = b"a"*16
pt2 = b"~"*16
new_pt1, new_pt2 = send_encrypted(io, "1", pt1+pt2+b"a")
new_ct1, new_ct2 = send_encrypted(io, "2", pt1+pt2+b"a", code)


# Solve:
new_pt1 = aes.bytes2matrix(new_pt1)
aes.sub_bytes(new_pt1)
aes.shift_rows(new_pt1)
aes.mix_columns(new_pt1)
new_pt1 = aes.matrix2bytes(new_pt1)

new_pt2 = aes.bytes2matrix(new_pt2)
aes.sub_bytes(new_pt2)
aes.shift_rows(new_pt2)
aes.mix_columns(new_pt2)
new_pt2 = aes.matrix2bytes(new_pt2)

ct1_prime = aes.bytes2matrix(new_ct1)
aes.inv_mix_columns(ct1_prime)
aes.inv_shift_rows(ct1_prime)
ct1_prime = aes.matrix2bytes(ct1_prime)

ct2_prime = aes.bytes2matrix(new_ct2)
aes.inv_mix_columns(ct2_prime)
aes.inv_shift_rows(ct2_prime)
ct2_prime = aes.matrix2bytes(ct2_prime)

possible_key24: list[list[int]] = [[] for _ in range(key_size)]

for bit in range(key_size):
    for sub_k_24_guess in range(256):
        sub_k_25_guess_1 = ct1_prime[bit] ^ aes.s_box[new_pt1[bit] ^ sub_k_24_guess]
        sub_k_25_guess_2 = ct2_prime[bit] ^ aes.s_box[new_pt2[bit] ^ sub_k_24_guess]
        if sub_k_25_guess_1 == sub_k_25_guess_2:
            # possible_key1[bit].append(k_1_guess_1)
            possible_key24[bit].append(sub_k_24_guess)

print(possible_key24)



def test_key(pt1, pt2, ct1, ct2, key) -> bool:
    ct_test = encrypt_block(pt1, key, PREMIUM_ROUNDS)
    if ct_test == ct1:
        return True
    ct_test = encrypt_block(pt2, key, PREMIUM_ROUNDS)
    if ct_test == ct2:
        return True
    return False


all_possible_keys = list(itertools.product(*possible_key24))
all_possible_keys = [bytes(k) for k in all_possible_keys]
print(len(all_possible_keys))


def get_master_key(key, rounds):
    offset = rounds % 10
    k = reverse_key_schedule(key, offset)
    key_rev = rounds // 10
    for _ in range(key_rev):
        k = reverse_key_schedule(k, 10)
    return k

for k in all_possible_keys:
    # Reverse key schedule
    master_key = get_master_key(k, NORMAL_ROUND+1)
    # k = reverse_key_schedule(k, 10)
    if test_key(pt1, pt2, new_ct1, new_ct2, master_key):
        print(master_key)
        io.sendlineafter(b"Enter option", "3")
        io.sendlineafter(b"Enter key (hex): ", master_key.hex())
        data1 = io.recvall()
        print(data1)
        log.success(find_flag_fmt(data1))
        exit(0)
assert False  # Key not found
